Приложение стартует со сцены CharacterSelectionScene, которая содержит объект Controll и скрипт SceneThubnailsControll.
К скрипту подключается: коллекция героев (Scriptable Object), текстура в которую рендерить, префаб виджета для отображения превью героя в UI, ссылка на инвентарь героя (Scriptable Object).
Скрипт иницилизирует Renderer текстурой Render Target, добавляет виджеты героев (ThubnailWidget) в скролл, инстанциирует префабы героев для рендера внутри себя и регистрирует их в  Renderer.
Также скрипт инициализирует каждого героя: инвентарь через CharacterInvetory, связывает CharacterInvetory сохраненный в InventoryDataStore инвентарь, включает зацикленную анимацию через AnimationSwitcher.

При нажатии на иконку героя, его айдишник передается в статический класс CharacterChoise, метод LoadCharacterPreviewScene загружает сцену CharacterPreviewScene с превью героя.

Сцена CharacterPreviewScene содержит объект Controller и скрипт CharacterPreviewController.

Система рендера.
Представлена классом-одиночкой Renderer и вспомогательным классом для передачи данных - RenderInfo.
Для размещения большого количества объектов на одной текстуре используется подход модификации View Port камеры.
Таким образом префаб объекта (героя) должен содержать в себе: камеру, героя, объекты окружения и все остальное, что нужно.
Для связи класса Renderer с таким префабом используется класс ViewPortSetter. Он устанавливает параметры камеры, а также слои для объектов и света. Таким образом, эти объекты могут существовать в одной сцене и не мешать друг-другу.
Классу Renderer на вход при инициализации подается текстура Render Target и минимальный размер тайла. В зависимости от зарегистрировавшихся на рендер объектов этот класс пытается разместить их на текстуре.
Если достигнут минимальный размер тайла, то регистрация не проходит.
Класс Renderer позволяет также временно отключать неиспользуемых героев, если, например, их виджет вышел за пределы скролла. Слежение за этим осуществляется скриптом WidgetVisibilityControll.
Для оповещения виджетов об изменении положения тайла в текстуре служит интерфейс IUpdateImageListener.

Переключение анимаций.
Класс AnimationSwitcher, который у Animator принудительно запускает анимации по enum AnimationType, если мы в окне просмотра персонажа (CharacterPreviewController это обеспечивает).
Либо, в окне выбора персонажа через систему переходов в Animator по bool переменной LoopMode проходит по всем анимациям, которые соединены.

Инвентарь игрока.
Разбит на категории: Helmets и Weapons. Можно добавить категорию, изменить в Editor/InventoryCategoryList.
Описание доступных предметов находится в InventoryDB. Каждый предмет имеет уникальный id (Read Only), который генерится автоматически. Здесь же указывается иконка и префаб предмета.
На объекте персонажа, инвентарь обслуживает скрипт CharacterInvetory, который знает как одевать тот или иной предмет. В редакторе настраивается связь айдишника предмета и настроенного плейсхолдера для него в костях персонажа.
CharacterInvetory также реализует интерфейс ICharacterCanWear. Если в инвентаре игрока не настроен биндинг для айдишника предмета, то метод CanWear вернет false и иконка для этого предмета для данного героя не будет показана в интерфейсе.

Переключение материалов.
Класс CharacterMaterialSetter работает с классами MaterialSetter. Скрипт MaterialSetter навешивается либо автоматически, либо в редакторе и позволяет установить новый материал, а так же хранит исходный материал.
Созданы 2 материала: ThermalView и PhantomView.
ThermalView - "термический"  режим. Сделан на технологии MCap с помощью текстуры Thermo.png и шейдера MatCap_TextureMultNew. В шейдер передается 3 вектора, которые образуют кастомную матрицу вида, изменяя параметры которой можно менять внешний вид эффекта.
PhantomView - режим голограммы. Так же сделан на технологии MCap, текстуры, шейдера Phantom MatCap_Plain_AdditiveZ. В шейдере можно менять цвет.

Поворот головы персонажа к камере.
Обслуживается классом CharacterLookAt, который управляет инверсной кинематикой в Animator.

Вращение персонажа.
Класс InputHandler. Поддерживает ввод с помощью мышки, если тачи не доступны.
Класс KineticRotation обеспечивает инерционное вращение персонажа. Параметры находятся в KineticRotationDB.
Параметр Filter позволяет создать "усилие" и избежать дребезга в начале вращения. 
Параметр Deceleration - скорость замедления.

Блик на кнопке Apply.
Текущий выбор предметов на экране просмотра хранит класс InventoryCurrentChoiseHolder, который может сравнить его с тем, что записано в сохранку.
То есть, если при очередном выборе предмета, если метод HasChanges класса InventoryCurrentChoiseHolder вернет true, то запуститься анимация блика (BlickAnimation). В ней анимируется параметр BlickPosition класса BlickAnimation. Этот параметр затем передается в шейдер в Update.
Блик сделан на шейдере Blick, положение блика - _offsetX, размер - _sizeX, так же есть возможность указать интенсивность - _intensity. В шейдере указан режим смешивания Add. Предполагается, что Image с таким шейдеров накладывается поверх кнопки.